use crate::CertmasterEvent;
use redis::FromRedisValue;
use redis_derive::FromRedisValue;
use serde::Deserialize;
use serde::Serialize;

pub const NEW_CSR_EVENT_GROUP: &str = "new-csr";
pub const CHALLENGE_EVENT_GROUP: &str = "challenge";
pub const JOB_PROGRESS_EVENT_GROUP: &str = "job-progress";
pub const FINISHED_EVENT_GROUP: &str = "finished";

#[derive(Debug, Clone, FromRedisValue, Serialize, Deserialize)]
pub struct NewCsr {
    /// The client ID is an ID generated by the client. When combined with a hash of the PEM string, it can be used to locate the job.
    pub client_id: u64,
    pub pem: PEMString,
}

impl CertmasterEvent for NewCsr {
    fn event_name() -> &'static str {
        NEW_CSR_EVENT_GROUP
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct AltName {
    pub client_id: u64,
    pub alias: CsrId
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct PendingChallenge {
    pub id: CsrId,
}

impl CertmasterEvent for PendingChallenge {
    fn event_name() -> &'static str {
        CHALLENGE_EVENT_GROUP
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct JobProgress {
    pub id: CsrId,
    pub status: JobStatus,
}

impl CertmasterEvent for JobProgress {
    fn event_name() -> &'static str {
        JOB_PROGRESS_EVENT_GROUP
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct Completion {
    pub id: CsrId,
    pub certificate: PEMString,
}

impl CertmasterEvent for Completion {
    fn event_name() -> &'static str {
        FINISHED_EVENT_GROUP
    }
}

pub type PEMString = String;
pub type CsrId = u64;

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct Csr {
    pub client_id: u64,
    pub(crate) pem: PEMString,
    pub status: JobStatus,
}

impl Csr {
    pub fn pem(&self) -> &PEMString {
        &self.pem
    }
}

impl From<NewCsr> for Csr {
    fn from(csr: NewCsr) -> Csr {
        Csr {
            client_id: csr.client_id,
            pem: csr.pem,
            status: JobStatus::Pending
        }
    }
}

impl From<PEMString> for Csr {
    fn from(value: PEMString) -> Self {
        Self {
            client_id: 0,
            pem: value,
            status: JobStatus::Pending
        }
    }
}

#[derive(Debug, Default, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub enum JobStatus {
    #[default]
    Pending,
    ChallengePending,
    ChallengePassed,
    ChallengeFailed {
        reason: String,
    },
    Finished,
    SigningError {
        reason: String,
    },
    Stale,
}
