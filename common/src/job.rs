use crate::{encode_base64, CertmasterEvent};
use redis::FromRedisValue;
use redis_derive::FromRedisValue;
use serde::Deserialize;
use serde::Serialize;

pub const NEW_CSR_EVENT_GROUP: &str = "new-csr";
pub const CHALLENGE_EVENT_GROUP: &str = "challenge";
pub const JOB_PROGRESS_EVENT_GROUP: &str = "job-progress";
pub const FINISHED_EVENT_GROUP: &str = "finished";

#[derive(Debug, Clone, FromRedisValue, Serialize, Deserialize)]
pub struct NewCsr {
    /// The client ID is an ID generated by the client. When combined with a hash of the PEM string, it can be used to locate the job.
    pub client_id: u64,
    pub pem: PEMString,
}

impl CertmasterEvent for NewCsr {
    fn event_name() -> &'static str {
        NEW_CSR_EVENT_GROUP
    }
}

impl NewCsr {
    pub fn alt(&self) -> String {
        crate::get_alt_name(self.client_id, &self.pem)
    }
}

/// This struct contains state that is relevant to the client.
#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct ClientJob {
    pub client_id: u64,
    pub serial: CsrId,
    pub alias: String,
    pub status: Status
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Status {
    Pending,
    Success {
        certificate: PEMString
    },
    Error {
        reason: String
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct PendingChallenge {
    pub id: CsrId,
}

impl CertmasterEvent for PendingChallenge {
    fn event_name() -> &'static str {
        CHALLENGE_EVENT_GROUP
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct JobProgress {
    pub id: CsrId,
    pub status: JobStatus,
}

impl CertmasterEvent for JobProgress {
    fn event_name() -> &'static str {
        JOB_PROGRESS_EVENT_GROUP
    }
}

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct Completion {
    pub id: CsrId,
    pub client_id: u64,
    pub certificate: PEMString,
}

impl CertmasterEvent for Completion {
    fn event_name() -> &'static str {
        FINISHED_EVENT_GROUP
    }
}

pub type PEMString = String;
pub type CsrId = u64;

#[derive(Debug, FromRedisValue, Serialize, Deserialize)]
pub struct Csr {
    #[serde(rename = "clientId")]
    pub client_id: u64,
    pub(crate) pem: PEMString,

    #[serde(rename = "alias")]
    pub client_alias: String,

    pub status: JobStatus,
}

impl Csr {
    pub fn pem(&self) -> &PEMString {
        &self.pem
    }
}

impl From<NewCsr> for Csr {
    fn from(csr: NewCsr) -> Csr {
        let alt = blake3::hash(format!("{id};{pem}", id=csr.client_id, pem=csr.pem).as_bytes());
        let alt = encode_base64(alt.as_bytes());

        Csr {
            client_id: csr.client_id,
            client_alias: alt,
            pem: csr.pem,
            status: JobStatus::Pending
        }
    }
}

impl From<PEMString> for Csr {
    fn from(value: PEMString) -> Self {
        Self {
            client_id: 0,
            client_alias: encode_base64(format!("0;{value}")),
            pem: value,
            status: JobStatus::Pending
        }
    }
}

#[derive(Debug, Default, Clone, Eq, PartialEq, Serialize, Deserialize)]
pub enum JobStatus {
    #[default]
    Pending,
    ChallengePending,
    ChallengePassed,
    ChallengeFailed {
        reason: String,
    },
    Finished,
    SigningError {
        reason: String,
    },
    Stale,
}